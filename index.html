<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic-Tac-Toe</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation; /* Prevents double-tap zoom on mobile */
        }
        .cell {
            width: 100px;
            height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3rem; /* Increased font size for X and O */
            font-weight: bold;
            cursor: pointer;
            border: 2px solid #6B7280; /* gray-500 */
            transition: background-color 0.3s ease;
        }
        .cell:hover {
            background-color: #F3F4F6; /* gray-100 */
        }
        /* Remove border for specific cells to make it look like a tic-tac-toe board */
        .cell:nth-child(1), .cell:nth-child(2), .cell:nth-child(3) {
            border-top: none;
        }
        .cell:nth-child(1), .cell:nth-child(4), .cell:nth-child(7) {
            border-left: none;
        }
        .cell:nth-child(3), .cell:nth-child(6), .cell:nth-child(9) {
            border-right: none;
        }
        .cell:nth-child(7), .cell:nth-child(8), .cell:nth-child(9) {
            border-bottom: none;
        }
        .winning-cell {
            background-color: #A7F3D0 !important; /* green-200 */
            color: #047857; /* green-700 */
        }
        .disabled {
            cursor: not-allowed;
            opacity: 0.7;
        }
        .message-box {
            min-height: 30px; /* Ensure space for message */
            font-weight: 500;
        }
        /* Custom modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            text-align: center;
        }
        .modal-button {
            margin-top: 1rem;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-weight: 500;
            cursor: pointer;
        }
    </style>
</head>
<body class="bg-slate-100 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="bg-white p-6 md:p-8 rounded-lg shadow-xl w-full max-w-md">
        <h1 class="text-3xl md:text-4xl font-bold text-center text-sky-600 mb-6">Tic-Tac-Toe</h1>

        <div id="gameBoard" class="grid grid-cols-3 gap-0 mx-auto w-max rounded-lg overflow-hidden shadow-md bg-white">
            <!-- Cells will be generated by JavaScript -->
        </div>

        <div id="statusMessage" class="message-box text-center text-xl mt-6 mb-4 text-slate-700">Player X's turn</div>

        <button id="resetButton" class="w-full bg-sky-500 hover:bg-sky-600 text-white font-semibold py-3 px-4 rounded-lg shadow transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-sky-400 focus:ring-opacity-75">
            Reset Game
        </button>
    </div>

    <!-- Custom Modal for Game Over -->
    <div id="gameOverModal" class="modal-overlay hidden">
        <div class="modal-content">
            <p id="modalMessage" class="text-xl text-slate-700"></p>
            <button id="modalCloseButton" class="modal-button bg-sky-500 hover:bg-sky-600 text-white">Play Again</button>
        </div>
    </div>

    <script>
        // --- Game Variables ---
        const gameBoardElement = document.getElementById('gameBoard');
        const statusMessageElement = document.getElementById('statusMessage');
        const resetButton = document.getElementById('resetButton');
        const gameOverModal = document.getElementById('gameOverModal');
        const modalMessageElement = document.getElementById('modalMessage');
        const modalCloseButton = document.getElementById('modalCloseButton');

        const PLAYER_X = 'X';
        const PLAYER_O = 'O';
        let currentPlayer = PLAYER_X;
        let boardState = ['', '', '', '', '', '', '', '', '']; // 9 cells
        let gameActive = true;
        let cells = []; // To store cell DOM elements

        const winningCombinations = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
            [0, 4, 8], [2, 4, 6]             // Diagonals
        ];

        // --- Game Initialization ---
        function initializeGame() {
            // Create cells
            gameBoardElement.innerHTML = ''; // Clear previous cells if any
            cells = []; // Reset cells array
            boardState = ['', '', '', '', '', '', '', '', ''];
            currentPlayer = PLAYER_X;
            gameActive = true;

            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell', 'border-slate-400');
                // Add Tailwind classes for responsive cell size
                cell.classList.add('w-20', 'h-20', 'sm:w-24', 'sm:h-24', 'md:w-28', 'md:h-28', 'lg:w-32', 'lg:h-32');
                cell.dataset.index = i;
                cell.addEventListener('click', handleCellClick);
                cell.addEventListener('touchstart', handleCellClick, { passive: true }); // For touch devices
                gameBoardElement.appendChild(cell);
                cells.push(cell);
            }
            updateStatusMessage();
            hideModal();
            // Ensure board is not disabled visually
            gameBoardElement.classList.remove('disabled');
        }

        // --- Event Handlers ---
        function handleCellClick(event) {
            if (!gameActive) return;

            const clickedCell = event.target;
            const cellIndex = parseInt(clickedCell.dataset.index);

            if (boardState[cellIndex] !== '' || currentPlayer !== PLAYER_X) {
                // Cell already taken or not player's turn
                return;
            }

            makeMove(cellIndex, PLAYER_X);

            if (gameActive) { // Check if game is still active after player's move
                currentPlayer = PLAYER_O;
                updateStatusMessage();
                // Disable board interaction during AI's turn visually
                gameBoardElement.classList.add('disabled');
                // AI's turn after a short delay for better UX
                setTimeout(aiMove, 600);
            }
        }

        resetButton.addEventListener('click', initializeGame);
        resetButton.addEventListener('touchstart', initializeGame, { passive: true });
        modalCloseButton.addEventListener('click', initializeGame);
        modalCloseButton.addEventListener('touchstart', initializeGame, { passive: true });


        // --- Game Logic ---
        function makeMove(index, player) {
            if (boardState[index] === '' && gameActive) {
                boardState[index] = player;
                cells[index].textContent = player;
                cells[index].classList.add(player === PLAYER_X ? 'text-blue-500' : 'text-red-500');
                cells[index].style.cursor = 'not-allowed'; // Disable cursor for played cell

                if (checkWin(player)) {
                    endGame(false, player);
                } else if (boardState.every(cell => cell !== '')) {
                    endGame(true); // It's a draw
                }
                return true; // Move was successful
            }
            return false; // Move was not successful
        }

        function checkWin(player) {
            return winningCombinations.some(combination => {
                const isWinning = combination.every(index => boardState[index] === player);
                if (isWinning) {
                    // Highlight winning cells
                    combination.forEach(index => cells[index].classList.add('winning-cell'));
                }
                return isWinning;
            });
        }

        function aiMove() {
            if (!gameActive || currentPlayer !== PLAYER_O) return;

            let bestMove = findBestMove();

            if (bestMove !== -1) {
                makeMove(bestMove, PLAYER_O);
            }

            if (gameActive) { // Check if game is still active after AI's move
                currentPlayer = PLAYER_X;
                updateStatusMessage();
            }
            // Re-enable board interaction after AI's turn
            gameBoardElement.classList.remove('disabled');
        }

        function findBestMove() {
            // AI Logic:
            // 1. Check if AI can win in the next move
            for (let i = 0; i < 9; i++) {
                if (boardState[i] === '') {
                    boardState[i] = PLAYER_O; // Try move
                    if (checkWin(PLAYER_O)) {
                        boardState[i] = ''; // Undo move for checkWin highlighting
                        return i;
                    }
                    boardState[i] = ''; // Undo move
                }
            }

            // 2. Check if Player X can win in the next move, and block them
            for (let i = 0; i < 9; i++) {
                if (boardState[i] === '') {
                    boardState[i] = PLAYER_X; // Try move for player
                    if (checkWin(PLAYER_X)) {
                        boardState[i] = ''; // Undo move
                        return i; // Block this spot
                    }
                    boardState[i] = ''; // Undo move
                }
            }
            
            // 3. Try to take the center if available
            if (boardState[4] === '') {
                return 4;
            }

            // 4. Try to take a corner if available
            const corners = [0, 2, 6, 8];
            const availableCorners = corners.filter(index => boardState[index] === '');
            if (availableCorners.length > 0) {
                return availableCorners[Math.floor(Math.random() * availableCorners.length)];
            }

            // 5. Take any available side
            const sides = [1, 3, 5, 7];
            const availableSides = sides.filter(index => boardState[index] === '');
            if (availableSides.length > 0) {
                return availableSides[Math.floor(Math.random() * availableSides.length)];
            }
            
            // 6. Fallback: Take any available spot (shouldn't be reached if logic is complete)
            const availableSpots = boardState.map((val, idx) => val === '' ? idx : -1).filter(idx => idx !== -1);
            if (availableSpots.length > 0) {
                return availableSpots[Math.floor(Math.random() * availableSpots.length)];
            }

            return -1; // Should not happen in a normal game
        }


        function endGame(draw, winner = null) {
            gameActive = false;
            let message = '';
            if (draw) {
                message = "It's a Draw!";
                statusMessageElement.textContent = message;
            } else {
                message = `Player ${winner} Wins!`;
                statusMessageElement.textContent = message;
            }
            // Disable board interaction visually
            gameBoardElement.classList.add('disabled');
            showModal(message);
        }

        function updateStatusMessage() {
            if (!gameActive) return;
            statusMessageElement.textContent = `Player ${currentPlayer}'s turn`;
        }

        // --- Modal Functions ---
        function showModal(message) {
            modalMessageElement.textContent = message;
            gameOverModal.classList.remove('hidden');
        }

        function hideModal() {
            gameOverModal.classList.add('hidden');
        }

        // --- Start the game ---
        initializeGame();

        // Make canvas responsive on resize (adjust cell sizes if needed, though Tailwind handles much of this)
        window.addEventListener('resize', () => {
            // For this specific implementation, Tailwind's responsive classes handle cell resizing.
            // If using fixed pixel sizes in JS, you would recalculate and apply them here.
        });

    </script>
</body>
</html>
